library(verification)
library(doParallel)
library(rgenoud)
library(forecast)
library(verification)
library(doParallel)
library(rgenoud)
library(rugarch)
cl  <- makeCluster(detectCores())
registerDoParallel(cl)
setwd("~/Google Drive/Bath/research/demand_forecasting/kssm_rdev")
setwd("~/GitRepos/kssm_rdev")
setwd("~/GitRepos/kssm_rdev")
wm01_00       <- readRDS("0100_import-complete.rds")
importpar     <- readRDS("0100_import-parameter.rds")
s01           <- importpar[1]
s02           <- importpar[2]
s03           <- importpar[3]
sum_of_h      <- importpar[4]
data_size     <- importpar[5]
cus_list      <- seq(1,10)
frontierstp   <- 5                       # Number of demand bins (Stepwise frontier for portfolio optimisation)
win_size      <- c(4,24)                 # Small and large win_size (select only 2)
ahead_t       <- seq(1, (24/sum_of_h))   # Up to s02
hrz_lim       <- seq(0,1)*2537
in_sample_fr  <- 1/6                     # Fraction for diving in- and out-sample
crossvalsize  <- 1                       # Number of weeks in the end of in_sample used for crossvalidation
crossvalstps  <- 2                       # Steps used for multiple crossvalidation
seas_bloc_ws  <- 6                       # Number of weeks used for calculating seasonality pattern (6 seems best)
sampling      <- 1024                    # For monte-carlo CRPS calculation
fx_evhor <- function (wm01_01,h,in_sample_fr,s02,seas_bloc_ws,crossvalsize){
event_horizon <- ncol(wm01_01) * in_sample_fr + 1 + h - s02
in_sample_ini <- event_horizon - min((seas_bloc_ws),(event_horizon %/% s02)) * s02 + 1
outsample_end <- event_horizon + max(ahead_t)
in_sample_siz <- event_horizon - in_sample_ini + 1
outsample_siz <- outsample_end - event_horizon
inosample_siz <- in_sample_siz + outsample_siz
crossval_ini  <- in_sample_siz - crossvalsize * s02 + 1
event_hrz_mod <- crossval_ini - 1
if (crossvalsize==0){
crossval_ini=NA
crossval_end=NA
}
evhor_out     <- c(event_horizon,in_sample_ini,outsample_end,in_sample_siz,outsample_siz,inosample_siz,event_hrz_mod,crossval_ini)
return(evhor_out)
}
fx_seas   <- function (wm01,s01,s02,sum_of_h,def_evhor){
wm02    <- foreach (j = 1:nrow(wm01), .combine=c("rbind"), .packages=c("forecast")) %dopar% {
wv31i  <- wm01[j,1:def_evhor[7]]
wv32i  <- decompose(msts(wv31i,seasonal.periods=c(s01/sum_of_h,s02/sum_of_h)))
wv32is <- wv32i$seasonal[1:(s02)]
wv32is
}
return(wm02)
}
fx_unseas <- function (wm01,wm02,s02,def_evhor){
wm04    <- foreach (j = 1:nrow(wm01), .combine=c("rbind")) %dopar% {
wv33a  <- rep(wm02[j,],def_evhor[7]/s02)
wv33b  <- wm02[j,1:(def_evhor[6] - def_evhor[7])]
wv33   <- c(wv33a,wv33b)
wv34   <- wm01[j,] - wv33
wv34
}
return(wm04)
}
fx_fcst_kds <- function (wm04,win_size,def_evhor,sampling){
fcst_mc2    <- foreach (j = 1:nrow(wm04)) %dopar% {
denssmall <- density(wm04[j,(def_evhor[7] - win_size[1] + 1):(def_evhor[7])])
denslarge <- density(wm04[j,(def_evhor[7] - win_size[2] + 1):(def_evhor[7])])
fcstsmall <- sample(denssmall$x, sampling, replace=TRUE, prob=denssmall$y)
fcstlarge <- sample(denslarge$x, sampling, replace=TRUE, prob=denslarge$y)
data.frame(fcstsmall,denssmall$bw,fcstlarge,denslarge$bw)
}
return(fcst_mc2)
}
fx_fcst_armagarch <- function (wm04,out_evhor,sampling){
fcst_armagarch <- foreach (j = 1:nrow(wm04), .combine=c("rbind"), .packages=c("rugarch")) %dopar% {
runvec       <- wm04[j,1:out_evhor[7]]
# Defining ARMA lags
final.aic <- Inf
final.order <- c(0,0,0)
for (p in 0:5) for (q in 0:5) {
if ( p == 0 && q == 0) {
next
}
arimaFit = tryCatch(arima(runvec, order=c(p, 0, q)),
error=function( err ) FALSE,
warning=function( err ) FALSE )
if( !is.logical( arimaFit ) ) {
current.aic <- AIC(arimaFit)
if (current.aic < final.aic) {
final.aic <- current.aic
final.order <- c(p, 0, q)
final.arima <- arima(runvec, order=final.order)
}
} else {
next
}
}
# setting ARMA-GARCH spec (1,1)
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged")
# fitting ARMA-GARCH parameters and simulating
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
sim1 = ugarchsim(fit, n.sim = win_size[2], m.sim = sampling)
}
}
fx_crps_mc <- function (wm04,fcst_mc,def_evhor,sampling){
crps_mc2 <- foreach (j = 1:nrow(wm04)) %:%
foreach (i = (def_evhor[4]+1):def_evhor[6], .combine=c("cbind"), .packages=c("verification")) %dopar% {
wv35s <- crps(rep(wm04[j,i],sampling),fcst_mc[[j]][,1:2])$CRPS
wv35l <- crps(rep(wm04[j,i],sampling),fcst_mc[[j]][,3:4])$CRPS
c(wv35s,wv35l)
}
return(crps_mc2)
}
fx_crossover <- function(fcst_mc,crps_mc,wm02,def_evhor){
wscoj <- foreach (j = 1:nrow(wm02),.combine=c("cbind")) %dopar% {
i=1
wscrossover <- 1
while (match(min(crps_mc[[j]][,i]),crps_mc[[j]][,i]) < 2 & i < def_evhor[5]){
wscrossover <- i+1
i <- i+1
}
wscrossover
}
return(wscoj)
}
fx_getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
fx_fcst_wm <- function(fcst_mc,cvcojmean,out_evhor,wm02){
fcst_co <- foreach (j = 1:nrow(wm02),.combine=c("rbind")) %dopar% {
wv36f <- matrix(ncol=out_evhor[5])
fcst1 <- colMeans(fcst_mc[[j]])[1]
fcst2 <- colMeans(fcst_mc[[j]])[3]
wv36f[1:cvcojmean[j]] <- as.numeric(fcst1)
if (cvcojmean[j]<out_evhor[5]) {
wv36f[cvcojmean[j]:out_evhor[5]]=as.numeric(fcst2)
}
wv33b <- wm02[j,1:(out_evhor[6] - out_evhor[7])]
(wv36f+wv33b)
}
}
fx_crps_wm <- function(crps_mc,cvcojmean,out_evhor,wm02){
crps_co <- foreach (j = 1:nrow(wm02),.combine=c("rbind")) %dopar% {
wv36c <- matrix(ncol=out_evhor[5])
wv36c[1:cvcojmean[j]] <- crps_mc[[j]][1,1:cvcojmean[j]]
if (cvcojmean[j]<out_evhor[5]) {
wv36c[cvcojmean[j]:out_evhor[5]]=crps_mc[[j]][2,cvcojmean[j]:out_evhor[5]]
}
wv36c
}
}
fx_rndgrp <- function(wm01,frontierstp){
rndgrp <- foreach (i = 1:frontierstp, .combine=c("rbind")) %:%
foreach (j = 1:nrow(wm01), .combine=c("rbind")) %dopar%{
rndgrp_pll <- (runif(nrow(wm01))<=(i/(frontierstp+0.3)))+0
while (sum(rndgrp_pll)==0){rndgrp_pll <- (runif(nrow(wm01))<=(i/10))+0}
rndgrp_pll
}
result <- list(rndgrp %*% wm01,rndgrp)
return(result)
}
fx_sd_mymat <- function (mymat){
sdev <- foreach (i = 1:nrow(mymat),.combine=c("cbind")) %do%{
sd(mymat[i,])
}
return(as.numeric(sdev))
}
fx_optgrp_crps <- function (wv42){
if (sum(wv42*wv45) > opt_min_cusd & sum(wv42*wv45) <= opt_max_cusd){
fv01   <- rbind(wv42 %*% wm01_01 / sum(wv42),0)
fl02   <- fx_int_cvfcst_kd(fv01,h,in_sample_fr,s01,s02,sum_of_h,win_size,seas_bloc_ws,crossvalsize,F)
result <- as.numeric(fl02[[2]][1,1])
} else {result <- 10}
return (result)
}
fx_optgrp_sdev <- function (wv42){
if (sum(wv42*wv45) > opt_min_cusd & sum(wv42*wv45) <= opt_max_cusd){
sd_evhor <- fx_evhor(wm01_01,h,in_sample_fr,s02,seas_bloc_ws,crossvalsize)
fv01     <- as.numeric(wv42 %*% wm01_01[,sd_evhor[2]:sd_evhor[1]] / sum(wv42))
fv02     <- decompose(msts(fv01,seasonal.periods=c(s01/sum_of_h,s02/sum_of_h)))
fv03     <- fv01 - fv02$seasonal
result   <- sd(fv03)
} else {result <- 10}
return (result)
}
fx_plt_mymat <- function(wm05){
plot(range(1:ncol(wm05)), range(min(wm05),max(wm05)), bty="n", type="n")
grid (NA,NULL, lty = 'dotted')
par(mar=c(5,4,4,3.5), xpd=TRUE)
colors   = rainbow(nrow(wm05))
linetype = c(1:3)
for (i in 1:nrow(wm05)){
lines(wm05[i,], type="l", lwd=1.5, lty=linetype[1],col=colors[i])
}
wm05mean <- colMeans(wm05)
lines(wm05mean, type="l", lwd=3, lty=linetype[2])
}
fx_plt_rnd_vs_opt <- function(bighlp,myrangex,myrangey,xunit) {
plot(myrangex,myrangey, bty="n", type="n", xlab=xunit,
ylab="Mean Demand",main=paste("optimum vs random groups for h =",bighlp[[1]]))
grid (NA,NULL, lty = 'dotted')
mycolors=c("darkgreen","green","darkblue","blue")
points(bighlp[[2]][,1],bighlp[[2]][,2],col="gray80",pch=20)
for (i in 3:length(bighlp)){
points(bighlp[[i]][,1],bighlp[[i]][,2],col=mycolors[i-2],pch=20)
}
legend('topright', inset=c(0,0), legend = c("random","opt_sdev_outsample","opt_sdev_insample","opt_crps_outsample","opt_crps_insample"),
lty=1, col=c("gray80",mycolors), bty='n', cex=.75, title="Grouping")
}
fx_int_cvfcst_kd <- function(wm01_01,h,in_sample_fr,s01,s02,sum_of_h,win_size,seas_bloc_ws,crossvalsize,fcst_run){
def_evhor  <- fx_evhor(wm01_01,h,in_sample_fr,s02,seas_bloc_ws,crossvalsize)
wm01       <- wm01_01[,def_evhor[2]:def_evhor[3]]                # work matrix
# ------ Cross Validation ----------------
cross_seq     <- seq(def_evhor[8],def_evhor[4]-max(ahead_t),round((def_evhor[4]-max(ahead_t)-def_evhor[7])/crossvalstps))
crossval_runs <- foreach (k = cross_seq, .combine=c('rbind')) %do%{
co_evhor    <- fx_evhor(wm01,k,0,s02,seas_bloc_ws,0)
wm01cv      <- wm01[,co_evhor[2]:co_evhor[3]]                  # work matrix
wm02cv      <- fx_seas(wm01cv,s01,s02,sum_of_h,co_evhor)       # in-sample seasonality pattern
wm03cv      <- wm01cv[,(co_evhor[4]+1):co_evhor[6]]            # out-sample original load data
wm04cv      <- fx_unseas(wm01cv,wm02cv,s02,co_evhor)           # in-out sample unseasonalised
fcst_mccv   <- fx_fcst_kds(wm04cv,win_size,co_evhor,sampling)
crps_mccv   <- fx_crps_mc(wm04cv,fcst_mccv,co_evhor,sampling)
cvcoj       <- fx_crossover(fcst_mccv,crps_mccv,wm02cv,co_evhor)
wm05cv      <- fx_crps_wm(crps_mccv,cvcoj,co_evhor,wm02cv)
c(as.numeric(cvcoj),rowMeans(wm05cv))
}
cvcojmean <- foreach (a = 1:nrow(wm01),.combine=c("rbind")) %dopar%{
round(mean(crossval_runs[,a]))
}
cvcrpsmean <- foreach (a = (nrow(wm01)+1):(2*nrow(wm01)),.combine=c("rbind")) %dopar%{
mean(crossval_runs[,a])
}
if (fcst_run == F) {
return(list(cvcojmean,cvcrpsmean))
}
# ------ Forecasting & Verification ------
if (fcst_run == T) {
out_evhor  <- fx_evhor(wm01_01,h,in_sample_fr,s02,seas_bloc_ws,0)
wm02       <- fx_seas(wm01,s01,s02,sum_of_h,out_evhor)           # in-sample seasonality pattern
wm03       <- wm01[,(out_evhor[4]+1):out_evhor[6]]               # out-sample original load data
wm04       <- fx_unseas(wm01,wm02,s02,out_evhor)                 # in-out sample unseasonalised
fcst_mc    <- fx_fcst_kds(wm04,win_size,out_evhor,sampling)
crps_mc    <- fx_crps_mc(wm04,fcst_mc,out_evhor,sampling)
wm03fcst   <- fx_fcst_wm(fcst_mc,cvcojmean,out_evhor,wm02)
wm05       <- fx_crps_wm(crps_mc,cvcojmean,out_evhor,wm02)
return(list(wm03fcst,wm05,wm04[,1:out_evhor[7]]))
}
}
wm01_01    <- wm01_00[min(cus_list):length(cus_list),]
wm01=wm01_01
out_evhor  <- fx_evhor(wm01_01,h,in_sample_fr,s02,seas_bloc_ws,0)
h=0
out_evhor  <- fx_evhor(wm01_01,h,in_sample_fr,s02,seas_bloc_ws,0)
wm02       <- fx_seas(wm01,s01,s02,sum_of_h,out_evhor)           # in-sample seasonality pattern
wm03       <- wm01[,(out_evhor[4]+1):out_evhor[6]]               # out-sample original load data
wm04       <- fx_unseas(wm01,wm02,s02,out_evhor)                 # in-out sample unseasonalised
fcst_mc    <- fx_fcst_kds(wm04,win_size,out_evhor,sampling)
j=5
runvec       <- wm04[j,1:out_evhor[7]]
final.aic <- Inf
final.order <- c(0,0,0)
for (p in 0:5) for (q in 0:5) {
if ( p == 0 && q == 0) {
next
}
arimaFit = tryCatch(arima(runvec, order=c(p, 0, q)),
error=function( err ) FALSE,
warning=function( err ) FALSE )
if( !is.logical( arimaFit ) ) {
current.aic <- AIC(arimaFit)
if (current.aic < final.aic) {
final.aic <- current.aic
final.order <- c(p, 0, q)
final.arima <- arima(runvec, order=final.order)
}
} else {
next
}
}
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged")
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
sim1 = ugarchsim(fit, n.sim = win_size[2], m.sim = sampling)
sim1@simulation$seriesSim
sim1@simulation$seriesSim
fcst_mc
list(sim1@simulation$seriesSim,sim1@simulation$sigmaSim)
fcst_armagarch <- foreach (j = 1:nrow(wm04), .packages=c("rugarch")) %dopar% {
runvec       <- wm04[j,1:out_evhor[7]]
# Defining ARMA lags
final.aic <- Inf
final.order <- c(0,0,0)
for (p in 0:5) for (q in 0:5) {
if ( p == 0 && q == 0) {
next
}
arimaFit = tryCatch(arima(runvec, order=c(p, 0, q)),
error=function( err ) FALSE,
warning=function( err ) FALSE )
if( !is.logical( arimaFit ) ) {
current.aic <- AIC(arimaFit)
if (current.aic < final.aic) {
final.aic <- current.aic
final.order <- c(p, 0, q)
final.arima <- arima(runvec, order=final.order)
}
} else {
next
}
}
# setting ARMA-GARCH spec (1,1)
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged")
# fitting ARMA-GARCH parameters and simulating
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
sim1 = ugarchsim(fit, n.sim = win_size[2], m.sim = sampling)
list(sim1@simulation$seriesSim,sim1@simulation$sigmaSim)
}
j=1
runvec       <- wm04[j,1:out_evhor[7]]
final.aic <- Inf
final.order <- c(0,0,0)
for (p in 0:5) for (q in 0:5) {
if ( p == 0 && q == 0) {
next
}
arimaFit = tryCatch(arima(runvec, order=c(p, 0, q)),
error=function( err ) FALSE,
warning=function( err ) FALSE )
if( !is.logical( arimaFit ) ) {
current.aic <- AIC(arimaFit)
if (current.aic < final.aic) {
final.aic <- current.aic
final.order <- c(p, 0, q)
final.arima <- arima(runvec, order=final.order)
}
} else {
next
}
}
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged")
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
sim1 = ugarchsim(fit, n.sim = win_size[2], m.sim = sampling)
j=2
runvec       <- wm04[j,1:out_evhor[7]]
final.aic <- Inf
final.order <- c(0,0,0)
for (p in 0:5) for (q in 0:5) {
if ( p == 0 && q == 0) {
next
}
arimaFit = tryCatch(arima(runvec, order=c(p, 0, q)),
error=function( err ) FALSE,
warning=function( err ) FALSE )
if( !is.logical( arimaFit ) ) {
current.aic <- AIC(arimaFit)
if (current.aic < final.aic) {
final.aic <- current.aic
final.order <- c(p, 0, q)
final.arima <- arima(runvec, order=final.order)
}
} else {
next
}
}
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged")
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
sim1 = ugarchsim(fit, n.sim = win_size[2], m.sim = sampling)
j=2
runvec       <- wm04[j,1:out_evhor[7]]
j=3
runvec       <- wm04[j,1:out_evhor[7]]
final.aic <- Inf
final.order <- c(0,0,0)
for (p in 0:5) for (q in 0:5) {
if ( p == 0 && q == 0) {
next
}
arimaFit = tryCatch(arima(runvec, order=c(p, 0, q)),
error=function( err ) FALSE,
warning=function( err ) FALSE )
if( !is.logical( arimaFit ) ) {
current.aic <- AIC(arimaFit)
if (current.aic < final.aic) {
final.aic <- current.aic
final.order <- c(p, 0, q)
final.arima <- arima(runvec, order=final.order)
}
} else {
next
}
}
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged")
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
sim1 = ugarchsim(fit, n.sim = win_size[2], m.sim = sampling)
j=4
runvec       <- wm04[j,1:out_evhor[7]]
final.aic <- Inf
final.order <- c(0,0,0)
for (p in 0:5) for (q in 0:5) {
if ( p == 0 && q == 0) {
next
}
arimaFit = tryCatch(arima(runvec, order=c(p, 0, q)),
error=function( err ) FALSE,
warning=function( err ) FALSE )
if( !is.logical( arimaFit ) ) {
current.aic <- AIC(arimaFit)
if (current.aic < final.aic) {
final.aic <- current.aic
final.order <- c(p, 0, q)
final.arima <- arima(runvec, order=final.order)
}
} else {
next
}
}
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged")
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
sim1 = ugarchsim(fit, n.sim = win_size[2], m.sim = sampling)
j=5
runvec       <- wm04[j,1:out_evhor[7]]
final.aic <- Inf
final.order <- c(0,0,0)
for (p in 0:5) for (q in 0:5) {
if ( p == 0 && q == 0) {
next
}
arimaFit = tryCatch(arima(runvec, order=c(p, 0, q)),
error=function( err ) FALSE,
warning=function( err ) FALSE )
if( !is.logical( arimaFit ) ) {
current.aic <- AIC(arimaFit)
if (current.aic < final.aic) {
final.aic <- current.aic
final.order <- c(p, 0, q)
final.arima <- arima(runvec, order=final.order)
}
} else {
next
}
}
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged")
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
sim1 = ugarchsim(fit, n.sim = win_size[2], m.sim = sampling)
j=6
runvec       <- wm04[j,1:out_evhor[7]]
final.aic <- Inf
final.order <- c(0,0,0)
for (p in 0:5) for (q in 0:5) {
if ( p == 0 && q == 0) {
next
}
arimaFit = tryCatch(arima(runvec, order=c(p, 0, q)),
error=function( err ) FALSE,
warning=function( err ) FALSE )
if( !is.logical( arimaFit ) ) {
current.aic <- AIC(arimaFit)
if (current.aic < final.aic) {
final.aic <- current.aic
final.order <- c(p, 0, q)
final.arima <- arima(runvec, order=final.order)
}
} else {
next
}
}
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged")
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
sim1 = ugarchsim(fit, n.sim = win_size[2], m.sim = sampling)
spec
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged")
fit = tryCatch(ugarchfit(spec, runvec, solver = 'hybrid'),
error=function(e) e, warning=function(w) w)
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged")
spec
